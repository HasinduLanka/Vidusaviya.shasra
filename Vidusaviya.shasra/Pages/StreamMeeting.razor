@inject IJSRuntime JsRuntime
@page "/streamer"
@using System.IO;

<h1>@stat</h1>

<input type="button" class="btn-sm btn-outline-primary" @onclick="Capture" value="Capture" />
<input type="button" class="btn-sm btn-@(IsRecording ? "danger" : "success")" @onclick="ToggleRecording" value="@((IsRecording ? "Stop recording" : "Start recording"))" />
<input type="button" id="recButton" class="btn-sm btn-primary" value="Share Screen" />
<div class="row">
    <div class="col-md-4">
        <center>
            <h6>Live Webcam</h6>
            <video id="video" width="480" height="360" autoplay></video>
        </center>
    </div>
    <div class="col-md-4">
        <center>
            <h6>Compressed feed</h6>
            <canvas id="midcanvas" width="480" height="360"></canvas>

            <h6>@(RunLoop?"⬤":"⏹")</h6>
        </center>
    </div>
    <div class="col-md-4">
        <center>
            <h6>Captured Video</h6>
            <canvas id="capturedImage" width="320" height="240"></canvas>
            <h4>@msg</h4>
        </center>
    </div>
</div>

<hr />
<div class="row">
    <div class="col-md-6">
        <center>
            <h5>Peer simulation</h5>
            <video id="video2" width="1280" height="720" autoplay></video>
        </center>
    </div>
    <div class="col-md-6">
        <center>
            <h5>Screen Share</h5>
            <video id="screenVideo" width="1280" height="720" autoplay></video>
        </center>
    </div>
</div>


@code
{


    // style="display: none"

    public string stat { get; set; }
    public string msg { get; set; }
    public bool IsRecording = false;
    public bool IsRecordingScreen = false;



    public System.Timers.Timer Timer;
    public System.Diagnostics.Stopwatch Stopwatch = new System.Diagnostics.Stopwatch();

    static FileAsyncManager<string> fileAsyncManager;
    static FileAsyncManager<string> downloadAsyncManager;

    MeetingStreamerSettings settings;
    static MeetingPeerSettings PeerSettings;



    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);


        if (firstRender)
        {
            Console.WriteLine("I'm hit");

            Stopwatch.Start();

            stat = await JsRuntime.InvokeAsync<string>("SayHi", "C Sharp");

            settings = Vidusaviya.shasra.Testing.RepoInfo.TestMeeting;
            await StartMeeting();

            stat = await JsRuntime.InvokeAsync<string>("StartPreview", Array.Empty<string>());
            await JsRuntime.InvokeAsync<string>("InitScreenRec", "screenVideo", "recButton");

            stat = await downloadAsyncManager.Thread.FileClient.Upload("", "");

        }
    }

    async void Capture()
    {

        await JsRuntime.InvokeVoidAsync("Snap", "video", "capturedImage");
        var imageBytes = await JsRuntime.InvokeAsync<string>("GetImageData", "capturedImage", "image/bmp");
        // var data = Convert.FromBase64String(imageBytes); // get the image as byte array

    }



    async void ToggleRecording()
    {
        IsRecording = !IsRecording;

        if (IsRecording)
        {
            await JsRuntime.InvokeVoidAsync("StartRec");

            RunLoop = true;

            Timer = new System.Timers.Timer(LoopIntervel);
            Timer.Elapsed += StreamLoop;

            Timer.Start();

            // await this.InvokeAsync(StateHasChanged);


        }
        else
        {

            RunLoop = false;
            Timer.Stop();

            await JsRuntime.InvokeVoidAsync("StopRec");

            // await this.InvokeAsync(StateHasChanged);
        }
    }

    long LoopIntervel = 100;
    bool RunLoop = false;
    bool StreamLooping = false;

    Queue<string> uploads = new Queue<string>();

    async void StreamLoop(object sender, System.Timers.ElapsedEventArgs e)
    {
        //Loop:
        if (StreamLooping) return;
        StreamLooping = true;





        var thread = fileAsyncManager.Advance();

        if (thread.task != null)
        {
            string url = await thread.task;

            string hap;

            if (url != "NOTFOUND")
            {
                uploads.Enqueue(url);
                hap = $"Uploaded {url}";
            }
            else
            {
                hap = "";
            }

            long now = Stopwatch.ElapsedMilliseconds;
            long d = now - thread.LastTime;
            thread.LastTime = now;

            if (hap != "")
                Console.WriteLine($" {hap} in {d}");

        }
        else
        {
            thread.LastTime = Stopwatch.ElapsedMilliseconds;
        }

        Func<Task<string>> x = (async () =>
        {
            string bloburl = await JsRuntime.InvokeAsync<string>("GetWCStream", null);
            if (bloburl != "")
            {
                System.IO.Stream blb = await thread.FileClient.StreamFromURL(bloburl);
                byte[] B = ReadFully(blb);
                string I64 = Convert.ToBase64String(B);

            //await JsRuntime.InvokeVoidAsync("AppendVideo", B);

            msg = bloburl;

                string FileSuffix = (++thread.LastFileIndex).ToString();
                return await thread.FileClient.Upload(FileSuffix, I64);


            }
            msg = bloburl;
            return $"NOTFOUND";
        }

        );


        thread.task = x.Invoke();

        StreamLooping = false;


    }

    private static byte[] ReadFully(Stream input)
    {
        using (MemoryStream ms = new MemoryStream())
        {
            input.CopyTo(ms);
            return ms.ToArray();
        }
    }


    async Task StartMeeting()
    {

        switch (settings.CDNType)
        {
            case CDNType.FTP:
                break;

            case CDNType.Github:


                PeerSettings = settings.PeerSettings();
                int pscount = PeerSettings.URLPrefixes.Count();
                downloadAsyncManager = new FileAsyncManager<string>(pscount);

                for (int i = 0; i < pscount; i++)
                {
                    var thr = new FileAsyncThread<string>(new GitDownloadCient(PeerSettings.URLPrefixes[i]));
                    downloadAsyncManager.Threads[i] = thr;

                }



                int count = settings.GithubInfos.Count;
                fileAsyncManager = new FileAsyncManager<string>(count);


                int gi = 0;
                foreach (var gr in settings.GithubInfos)
                {
                    var thru = new FileAsyncThread<string>(new GitFileClient(gr.UName, gr.ps, gr.Repo, gr.Path));
                    fileAsyncManager.Threads[gi] = thru;
                    //thr.FileClient.DeleteAll().Wait();

                    thru.LastFileIndex = await thru.FileClient.GetLastFileIndex();
                    downloadAsyncManager.Threads[gi].LastFileIndex = thru.LastFileIndex;

                    Console.WriteLine($"{gi}. Selected LastFileIndex {thru.LastFileIndex}");


                    gi++;
                }




                break;

            case CDNType.Firestore:
                break;

            default:
                break;
        }



    }

}