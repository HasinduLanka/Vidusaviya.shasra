@inject IJSRuntime JsRuntime
@page "/streamer"
@using System.IO;

<h1>@stat</h1>

<input type="button" class="btn-sm btn-outline-primary" @onclick="CaptureCam" value="Capture Cam" />
<input type="button" class="btn-sm btn-@(IsRecordingCam ? "danger" : "success")" @onclick="ToggleRecordingCam" value="@((IsRecordingCam ? "Stop recording" : "Start recording"))" />
<hr />
<input type="button" class="btn-sm btn-outline-primary" @onclick="CaptureScreen" value="Capture Screen" />
<input type="button" class="btn-sm btn-@(IsRecordingScreen ? "danger" : "success")" @onclick="ToggleRecordingScreen" value="@((IsRecordingScreen ? "Stop Screen Sharing" : "Start Screen Sharing"))" />
<div class="row">
    <div class="col-md-4">
        <center>
            <h6>Live Webcam</h6>
            <video id="liveCam" width="480" height="360" autoplay></video>
        </center>
    </div>
    <div class="col-md-4">
        <center>
            <h6>Compressed Cam feed</h6>
            <canvas id="CompCavasCam" width="480" height="360"></canvas>
            <h6>@(RunLoopCam ? "⬤":"⏹")</h6>
        </center>
    </div>
    <div class="col-md-4">
        <center>
            <h6>Captured Cam Video</h6>
            <canvas id="capturedCam" width="320" height="240"></canvas>
            <h4>@msgCam</h4>
        </center>
    </div>
</div>
<hr />
<div class="row">
    <div class="col-md-4">
        <center>
            <h6>Live Screen</h6>
            <video id="liveScreen" width="480" height="360" autoplay></video>
        </center>
    </div>
    <div class="col-md-4">
        <center>
            <h6>Compressed Screen feed</h6>
            <canvas id="CompCavasScreen" width="480" height="360"></canvas>
            <h6>@(RunLoopScreen ? "⬤":"⏹")</h6>
        </center>
    </div>
    <div class="col-md-4">
        <center>
            <h6>Captured Screen Video</h6>
            <canvas id="capturedScreen" width="320" height="240"></canvas>
            <h4>@msgScreen</h4>
        </center>
    </div>
</div>
<hr />
<div class="row">
    <div class="col-md-6">
        <center>
            <h5>Peer simulation Cam</h5>
            <video id="camPerview" width="1280" height="720" autoplay></video>
        </center>
    </div>
    <div class="col-md-6">
        <center>
            <h5>Peer simulation Screen</h5>
            <video id="screenPreview" width="1280" height="720" autoplay></video>
        </center>
    </div>
</div>


@code
{


    // style="display: none"

    public string stat { get; set; }
    public string msgCam { get; set; }
    public string msgScreen { get; set; }
    public bool IsRecordingCam = false;
    public bool IsRecordingScreen = false;



    public System.Timers.Timer Timer;
    public System.Diagnostics.Stopwatch Stopwatch = new System.Diagnostics.Stopwatch();

    static FileAsyncManager<string> fileAsyncManager;
    static FileAsyncManager<string> downloadAsyncManager;

    MeetingStreamerSettings settings;
    static MeetingPeerSettings PeerSettings;



    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);


        if (firstRender)
        {
            Console.WriteLine("I'm hit");

            Stopwatch.Start();

            stat = await JsRuntime.InvokeAsync<string>("SayHi", "C Sharp");

            settings = Vidusaviya.shasra.Testing.RepoInfo.TestMeeting;
            await StartMeeting();

            stat = await JsRuntime.InvokeAsync<string>("StartPreviewCam", Array.Empty<string>());
            stat = await JsRuntime.InvokeAsync<string>("StartPreviewScreen", Array.Empty<string>());
            stat = await downloadAsyncManager.Thread.FileClient.Upload("", "");

        }
    }

    async void CaptureCam()
    {

        await JsRuntime.InvokeVoidAsync("SnapCam", "liveCam", "capturedCam");
        var imageBytes = await JsRuntime.InvokeAsync<string>("GetImageDataCam", "capturedCam", "image/bmp");
        // var data = Convert.FromBase64String(imageBytes); // get the image as byte array
    }
    async void CaptureScreen()
    {

        await JsRuntime.InvokeVoidAsync("SnapScreen", "liveScreen", "capturedScreen");
        var imageBytes = await JsRuntime.InvokeAsync<string>("GetImageDataScreen", "capturedScreen", "image/bmp");
        // var data = Convert.FromBase64String(imageBytes); // get the image as byte array
    }


    async void ToggleRecordingCam()
    {
        IsRecordingCam = !IsRecordingCam;

        if (IsRecordingCam)
        {
            await JsRuntime.InvokeVoidAsync("StartRecCam");

            RunLoopCam = true;

            Timer = new System.Timers.Timer(LoopIntervel);
            Timer.Elapsed += StreamLoopCam;

            Timer.Start();

            // await this.InvokeAsync(StateHasChanged);


        }
        else
        {

            RunLoopCam = false;
            Timer.Stop();

            await JsRuntime.InvokeVoidAsync("StopRecCam");

            // await this.InvokeAsync(StateHasChanged);
        }
    }

    async void ToggleRecordingScreen()
    {
        IsRecordingScreen = !IsRecordingScreen;

        if (IsRecordingScreen)
        {
            await JsRuntime.InvokeVoidAsync("StartRecScreen");

            RunLoopScreen = true;

            Timer = new System.Timers.Timer(LoopIntervel);
            Timer.Elapsed += StreamLoopScreen;

            Timer.Start();

            // await this.InvokeAsync(StateHasChanged);


        }
        else
        {

            RunLoopScreen = false;
            Timer.Stop();

            await JsRuntime.InvokeVoidAsync("StopRecScreen");

            // await this.InvokeAsync(StateHasChanged);
        }
    }

    long LoopIntervel = 100;
    bool RunLoopCam = false;
    bool RunLoopScreen = false;
    bool StreamLoopingCam = false;
    bool StreamLoopingScreen = false;

    Queue<string> uploads = new Queue<string>();

    async void StreamLoopCam(object sender, System.Timers.ElapsedEventArgs e)
    {
        //Loop:
        if (StreamLoopingCam) return;
        StreamLoopingCam = true;

        var thread = fileAsyncManager.Advance();

        if (thread.task != null)
        {
            string url = await thread.task;

            string hap;

            if (url != "NOTFOUND")
            {
                uploads.Enqueue(url);
                hap = $"Uploaded Cam Stream {url}";
            }
            else
            {
                hap = "";
            }

            long now = Stopwatch.ElapsedMilliseconds;
            long d = now - thread.LastTime;
            thread.LastTime = now;

            if (hap != "")
                Console.WriteLine($" {hap} in {d}");

        }
        else
        {
            thread.LastTime = Stopwatch.ElapsedMilliseconds;
        }

        Func<Task<string>> x = (async () =>
        {
            string bloburl = await JsRuntime.InvokeAsync<string>("GetWCStreamCam", null);
            if (bloburl != "")
            {
                System.IO.Stream blb = await thread.FileClient.StreamFromURL(bloburl);
                byte[] B = ReadFully(blb);
                string I64 = Convert.ToBase64String(B);

                //await JsRuntime.InvokeVoidAsync("AppendVideo", B);

                msgCam = bloburl;

                string FileSuffix = (++thread.LastFileIndex).ToString();
                return await thread.FileClient.Upload(FileSuffix, I64);


            }
            msgCam = bloburl;
            return $"NOTFOUND";
        }

        );


        thread.task = x.Invoke();

        StreamLoopingCam = false;


    }

    async void StreamLoopScreen(object sender, System.Timers.ElapsedEventArgs e)
    {
        //Loop:
        if (StreamLoopingScreen) return;
        StreamLoopingScreen = true;

        var thread = fileAsyncManager.Advance();

        if (thread.task != null)
        {
            string url = await thread.task;

            string hap;

            if (url != "NOTFOUND")
            {
                uploads.Enqueue(url);
                hap = $"Uploaded Screen Stream {url}";
            }
            else
            {
                hap = "";
            }

            long now = Stopwatch.ElapsedMilliseconds;
            long d = now - thread.LastTime;
            thread.LastTime = now;

            if (hap != "")
                Console.WriteLine($" {hap} in {d}");

        }
        else
        {
            thread.LastTime = Stopwatch.ElapsedMilliseconds;
        }

        Func<Task<string>> x = (async () =>
        {
            string bloburl = await JsRuntime.InvokeAsync<string>("GetWCStreamScreen", null);
            if (bloburl != "")
            {
                System.IO.Stream blb = await thread.FileClient.StreamFromURL(bloburl);
                byte[] B = ReadFully(blb);
                string I64 = Convert.ToBase64String(B);

                //await JsRuntime.InvokeVoidAsync("AppendVideo", B);

                msgScreen = bloburl;

                string FileSuffix = (++thread.LastFileIndex).ToString();
                return await thread.FileClient.Upload(FileSuffix, I64);


            }
            msgScreen = bloburl;
            return $"NOTFOUND";
        }

        );


        thread.task = x.Invoke();

        StreamLoopingScreen = false;


    }

    private static byte[] ReadFully(Stream input)
    {
        using (MemoryStream ms = new MemoryStream())
        {
            input.CopyTo(ms);
            return ms.ToArray();
        }
    }


    async Task StartMeeting()
    {

        switch (settings.CDNType)
        {
            case CDNType.FTP:
                break;

            case CDNType.Github:


                PeerSettings = settings.PeerSettings();
                int pscount = PeerSettings.URLPrefixes.Count();
                downloadAsyncManager = new FileAsyncManager<string>(pscount);

                for (int i = 0; i < pscount; i++)
                {
                    var thr = new FileAsyncThread<string>(new GitDownloadCient(PeerSettings.URLPrefixes[i]));
                    downloadAsyncManager.Threads[i] = thr;

                }



                int count = settings.GithubInfos.Count;
                fileAsyncManager = new FileAsyncManager<string>(count);


                int gi = 0;
                foreach (var gr in settings.GithubInfos)
                {
                    var thru = new FileAsyncThread<string>(new GitFileClient(gr.UName, gr.ps, gr.Repo, gr.Path));
                    fileAsyncManager.Threads[gi] = thru;
                    //thr.FileClient.DeleteAll().Wait();

                    thru.LastFileIndex = await thru.FileClient.GetLastFileIndex();
                    downloadAsyncManager.Threads[gi].LastFileIndex = thru.LastFileIndex;

                    Console.WriteLine($"{gi}. Selected LastFileIndex {thru.LastFileIndex}");


                    gi++;
                }




                break;

            case CDNType.Firestore:
                break;

            default:
                break;
        }



    }

}